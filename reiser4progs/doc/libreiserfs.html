<html>
<head><title>Reiser4 Libreiserfs Architecture Document.</title></head>
<body>

<table width=90%><tr><td align=center>
<h1>Reiser4 Libreiserfs Architecture Document.</h1>
<h3>24 May 2002</h2>
</td></tr></table>

<h2>Introduction</h2>
<table width=90%><tr><td align=justify>
This document consists of two parts. First part describes DAL as the way of communication 
with any device through unified interface.  Second  part describes libreiserfs that works 
over DAL.
</td></tr></table>

<h2>DAL (Device Abstraction Layer)</h2>
<table width=90%><tr><td align=justify>
DAL is a layer between the device abstract object in "master" software package that uses
libreiserfs and libreiserfs. DAL layer handles all I/O requests from libreiserfs to that 
device.
</td></tr></table>

<h3>Abstract</h3>

<table width=90%><tr><td align=justify>
<p>Following is not complete list of projects that are interested in 
using libreiserfs:<br>
GNU Parted, EVMS, GNU GRUB, Yaboot, Partimage, Reiserfsprogs.</p>

<i>Why is additional abstraction layer required in libreiserfs in order 
	to cooperate with these packages?</i>

<p>All these projects have their own abstract device that has 
additional properties but being plain UNIX block device.</p>

<p>For example: various "policies", backing up, checking,  logging, 
etc. Some of these device abstract objects doesn't have opened file
descriptor (for real device) corresponding to them at all. For 
example, GNU GRUB or Yaboot are boot loaders and as such
do not and can not use standard C library and kernel services.</p>

<p>Therefore  we  must export some "device-presentation independent" 
interface for all I/O operations. This  interface will be based 
on installable callback functions for every atomic I/O operation: 
to read from device, to write to device, to sync a device, to compare 
two devices, to obtain capacity	of device (number of bytes that can 
be stored on device) and to obtain flags device was opened with (read
only, read/write, etc).</p>

<i>Why should we burden ourselves with this?</i>

<p>This is because we want to build our library (libreiserfs) on
a stable interface. We have to rely on it. However I/O requirements 
vary from one project to another. Or do not exist at all.<p>

<p>In fact we are forcing all projects to use our DAL interface.  
Every  project implements our interface in order to be 
compatible with us.</p>

<p>So, as every software package from listed above has unique 
(in theory) device nature, it must have also own device-nature-specific 
I/O working functions implemented in it. These I/O working functions 
will very much vary from one project to another. For example, reiserfsprogs 
will be using just "read", "write", "stat" for file descriptor, GNU Parted 
will be using "ped_geometry_read", "ped_geometry_write" functions for 
PedGeometry object and GNU GRUB will be using "biosdisk" function that is 
call to int 0x13 interrupt in fact.</p>

<p>The  reiserfsprogs DAL object will be the simplest of them
all, since reiserfsprogs operates directly on a UNIX block
device (e.g., /dev/hda1), the reiserfsprogs implementation
of the abstract DAL operations  will  be  just  the  usual
read(),  write(),  and fsync() that operate on a UNIX file
descriptor.</p>

<p>The GNU Parted DAL object will be a bit more complex.  One
reason that Parted requires a more sophisticated DAL is
that it has, roughly speaking,  more  complex device
abstract object. Parted  is able to check for errors and
to abort current action if anything went wrong. Due to this 
more complex behavior, libreiserfs cannot operate directly
on a block device and file descriptor. Another feature  of
Parted is its support for partition "slices", which are
sub-partitions of a  single  block  device  (supported  on
FreeBSD, for example).</p>

<p>The GNU GRUB system is a bootloader, so it runs without
any kernel to support it. Therefore there must be a layer
of abstraction between libreiserfs and the client programs
that use it. Reiserfsprogs is a simple example that would
not require any DAL support, but support for a wider range
of libreiserfs applications will require a DAL layer to
interface with them.</p>

<p>So every project  that  is going to use libreiserfs should
prepare "dal_ops" structure and fill it by its device 
specific I/O working functions. This "dal_ops" structure
is the central component of DAL. To use DAL object for I/O 
operations, libreiserfs will call installed in "dal_ops" 
callback functions for every "read", "write", etc operation
every time as it will be needed to read, write something.</p>

<p>That is, all real I/O work is delegated to the appropriate
callback function. For example,  reiserfsck_read is to be called 
for reiserfsck. reiserfsck_read calls  standard read(2) 
function to read from supplied file descriptor.</p>

<p>For GNU Parted, ped_geometry_read callback function calls 
standard read(2) function, and for GNU GRUB, read callback 
calls "biosdisk" function.</p>

<p>Actually "ped_geometry_read" calls "ped_device_read" function.
"ped_device_read" function calls "read" operation from current
architecture's device operation descriptor. This "read" operation
is callback function in fact and may operate on file descriptor
of device (drive) (/dev/hda, /dev/hdb, etc).</p>

<p>For example, "dal_ops" for GNU GRUB looks roughly like this:</p>

<p>For example, this stuff lies in separate device.S file. Function "biosdisk" 
does all work on device.</p>
</td></tr></table>
	
<table width=90%><tr><td align=justify>
	
<pre>
ENTRY(biosdsik)
	...

	int $0x13

	...

	ret
</pre>

<p>This stuff lies in DAL implementation for GNU GRUB. Let it be 
bios_dal.c.</p>

<pre>
extern int biosdisk(some_parameters);

int bios_read(some_parameters) {
	return biosdisk(some_parameters);
}

int bios_write(some_parameters) {
	return biosdisk(some_parameters);
}

struct bios_dal_ops bios_ops {
	read: bios_read,
	write: bios_write,
	...
}
</pre>

<p>And after bios_dal_ops is ready, we will create dal_t that will 
contain bios_dal_ops in it.</p>

<pre>
dal_t *bios_dal_open(some_parameters) {

	return dal_open(bios_ops, some_parameters);
}
</pre>

<p>On other hand, reiserfsprogs will prepare  "file_dal_ops".
It will roughly look like:</p>

<pre>
int file_read(some_parameters) {
	return read(some_parameters);
}

int file_write(some_parameters) {
	return write(some_parameters);
}

struct file_dal_ops file_ops {
	read: file_read,
	write: file_write,
	...
}

dal_t *file_dal_open(some_parameters) {
	return dal_open(file_ops, some_parameters);
}
</pre>

<p>As you can see these two DALs have very different nature
and implementation.</p>

<p>Now lets show on Parted example, what happens when user 
issues command to resize partition with reiserfs on it. 
First of all we are interested in tracking of I/O operations.</p>

<ul>
<li>At user's request to resize partition, parted's parted-libreiserfs 
glue code creates an instance of "parted_dal" with installed 
into it own callback I/O operations, opens filesystem on it by 
"reiserfs_fs_open" and requests libreiserfs to perform filesystem 
resizing on passed "parted_dal".<br><br>

<li>At Parted's request, libreiserfs resizes given filesystem on 
given device (parted_dal) and for every I/O operation during resizing, 
libreiserfs calls I/O handlers from "parted_dal".<br><br>

<ul><li>In this stage execution control flows beetwen Parted and 
libreiserfs. Parted's I/O handlers do all I/O work (as usual 
reading or writing a block) and returns result to libreiserfs. 
libreiserfs continue working and again calls Parted's I/O handlers 
for reading, writing, etc.<br><br>
</ul>

<li>After libreiserfs finished resizing, it returns result of 
operation to Parted.
</ul>

<p>Therefore DAL is just simple and stable interface. I call it "stable", 
because it remains unchanged from one project to another.</p>
</td></tr></table>

<h3>Implementation.</h3>

<table width=90%><tr><td align=justify>
<p>Following is complete list of I/O operations that have  to be implemented 
by any DAL implementation.  Notice that not all of them have to do real 
work. For example, "stat" call is  only  required  just  for  proper stating 
of files and directories.  If "stat" not implemented, then stat  structure
(filled  by reiserfs_object_stat) will not contain a valid st_dev field.<p>

<pre>
struct dal_ops {
	int (*read)(dal_t *, void *, blk_t, count_t);
	int (*write)(dal_t *, void *, blk_t, count_t);
	int (*sync)(dal_t *);
	int (*flags)(dal_t *);
	int (*equals)(dal_t *, dal_t *);
	int (*stat)(dal_t *, struct stat *);
	blk_t (*len)(dal_t *);
	char *(*error) (dal_t *);
};
</pre>

<b>int (*read) (dal_t *dal, void *buff, blk_t block, count_t count)</b>

<p>Reads count of blocks into given buffer, starting from given block. 
Returns "true" on success, ""false" on failure. Used by reiserfs_block_read 
function for reading from device.</p>

<b>int (*write) (dal_t *dal, void *buff, blk_t block, count_t count)</b>

<p>Writes count of blocks from given buffer onto device, starting from given 
block. Returns "true" on success, "false" on failure. Used by reiserfs_block_write 
function for writing data to device.</p>

<p>Both "read" and "write" operations are atomic in context of returning data.
For example, in the case "read" was unable to read "count" of blocks, "read" 
will return error.</p>

<b>int (*sync) (dal_t *dal)</b>

<p>Syncs given device. Returns result. Used by front-ends for syncing device 
before it will be closed.</p>

<b>int (*flags) (dal_t *dal)</b>

<p>Returns the flags for pointed device. For example, O_RDWR, O_LARGEFILE,
etc. Used, for example, by reiserfs_fs_open.</p>

<b>int (*equals) (dal_t *dal1, dal_t *dal2)</b>

<p>Returns the result of comparing of dal1 and dal2. Widely used for determining
whether given DALs are equal.</p>

<p>Imagine, mkfs program is calling "reiserfs_fs_create" function in order to 
create reiserfs filesystem on a device with some properties (hash, format, 
block size, standard or relocated journal, etc).</p>

<p>"reiserfs_fs_create" function has two first arguments: host_dal - device 
where filesystem will be placed (superblock, bitmap, tree, etc) journal_dal - 
device where journal will be placed.</p>

<p>"journal_dal" may be the same as host_dal. And this is means "mkfs" is trying 
to create filesystem with standard journal. When "journal_dal" is some other 
device  that "host_dal", it is means "mkfs" is trying to create filesystem with 
relocated journal. In this case "journal_dal" will be used in order to perform 
I/O operations on that device for working with journal.  Replaying  journal, 
looking for logged block, etc.</p>

<p>Therefore libreiserfs core code must know whether DALs are different or not. 
The libreiserfs' behavior depends very much on equals callback.</p>

<p>"equals" callback is used also in "tune" routines. For example, when 
"tunefs" is trying to resize the journal in reiser3. If journal is standard 
then relocation of some region of tree also is needed and it will be performed. 
If journal is relocated (separated) then relocation will not be performed.</p>

<b>int (*stat) (dal_t *dal, struct stat* st)</b>

<p>Fills statistics buffer for dal, like standard <b>stat(2)</b>.
Used by journal opening and creating routines.</p>

<b>blk_t (*len) (dal_t *dal)</b>

<p>Returns actual device length in blocks. Used by libreiserfs in all cases 
where device length is needed. For example, it is used in reiserfs_super_check.  
This functions makes some checks on opened superblock and one of them is check 
whether sb_block_count is correct (less or equals than device length).</p>

<b>char *(*error) (dal_t *dal)</b>

<p>Returns last error.</p>

<p>Front-end application that wants to use libreiserfs over some specific storage, 
implements all above operations, packs them into dal_ops structure and calls 
dal_open to create DAL instance working over application-specific storage.</p>

<p>DAL functions and structures are following:</p>

<b>dal_t *dal_open(struct dal_ops *ops, const void *dev, size_t blocksize,<br>
int flags, void *data)</b>

<p>Allocates new instance of DAL that will use given operations. Sets blocksize
and user specific data for allocated DAL. Then actually opens device and returns 
initialized instance.</p>

<b>void dal_close(dal_t *dal)</b>

<p>Closes device, releases all memory associated with DAL.</p>

<b>int dal_set_blocksize(dal_t *dal, size_t blocksize)</b>
<b>size_t dal_blocksize(dal_t *dal)</b>

<p>Functions to set/get block size. dal_set_blocksize makes check whether given
block size is power of two and if so, sets new blocksize. Function dal_blocksize
returns blocksize of specified DAL. These functions are useful for changing block
size of underlying DAL. For example, default block size before reading the superblock
was 4096. After reading the superblock we have found that "blocksize" in the superblock
is not 4096 (for example 2048). And then we are setting up DAL for filesystem and 
DAL for journal by redded from superblock "blocksize" value. So we use "dal_set_blocksize"
to change block-sizes in host DAL and journal DAL to value read from superblock.</p>

<p>The functions below are wrappers for operations registered in DAL's "ops" field. They
check input parameters, check whether corresponding DAL's operation is implemented and
then call DAL's operation and return the result of operation to caller. These functions 
also public function, which will be used by "master" project.</p>

<p>See above for more detailed description.</p>

<b>int dal_read(dal_t *dal, void *buff, blk_t block, blk_t count)</b>

<p>Reads a number of blocks from DAL.</p>

<b>int dal_write(dal_t *dal, void *buff, blk_t block, blk_t count)</b>

<p>Writes a number of blocks to DAL.</p>

<b>int dal_sync(dal_t *dal)</b>

<p>Synchronizes specified DAL.</p>

<b>int dal_flags(dal_t *dal)</b>

<p>Returns flags from DAL.</p>

<b>int dal_equals(dal_t *dal1, dal_t *dal2)</b>

<p>Compares two DALs.</p>

<b>int dal_stat(dal_t *dal, struct stat *stat)</b>

<p>Makes stat for specified DAL.</p>

<b>blk_t dal_len(dal_t *dal)</b>

<p>Returns device length in blocks.</p>

<b>char *dal_error(dal_t *dal)</b>

<p>Returns last error.</p>

<p>dal_t struct has following fields:</p>

<pre>
struct dal {
	const void *dev;
	size_t blocksize;
	struct dal_ops *ops;

	int flags;
	void *data;
};

typedef struct dal dal_t;
</pre>

<b>struct dal_ops *ops</b>

<p>Set of operations for this device. Device operations affect the behavior of
device. See above for more details.</p>

<b>const void *dev</b>

<p>The opaque pointer to device private data. For example, for "file_dal" this is
pointer to opened file descriptor, for GNU Parted this is pointer to initialized
"PedGeometry" struct, etc.</p>

<b>size_t blocksize</b>

<p>The blocksize for this device. All offset calculations on it are based on this
field.</p>

<b>int flags</b>

<p>The flags with which device was opened.</p>

<b>void *data</b>

<p>Some device specific data. It may be used for any  purpose by particular DAL 
implementation provided by front-end. In file_dal this field is used to store 
file name in it.</p>

<p>Project that doesn't need to implement a special device (due to using standard 
file descriptor), may use file_dal - device abstraction for standard device or 
file. file_dal may be used in manner like this:</p>

<p>Here is example program that detecting reiserfs format on specified device.</p>

<pre>
#include &lt;stdio.h&gt;

#include &lt;dal/dal.h&gt;
#include &lt;reiserfs/reiserfs.h&gt;

int main (int argc, char *argv[]) {
	char *dev;

	dal_t *dal;
	reiserfs_fs_t *fs;

	if (argc &lt; 2) {
		 fprintf(stderr, "Usage: %s DEV\n", argv[0]);
		 return 0xfe;
	}

	dev = argv[1];

	if (!(dal = file_dal_open(dev))) {
		 libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			  "Couldn't open device %s." , dev);
		 goto error;
	}

	if (!(fs = reiserfs_fs_open(dal, dal))) {
		 libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			  "Couldn't open reiserfs on %s.", dev);
		 goto error_free_dal;
	}

	printf("Detected %s\n", reiserfs_fs_format(fs));
	
	reiserfs_fs_close(fs);
	file_dal_close(dal);
	
	return 0;
	
error_free_dal:
	file_dal_close(dal);
error:
	return 0xff;
}
</pre>

<p>As DALs passed into reiserfs_fs_open are identical, this an attempt
to open filesystem with standard journal. If filesystem has relocated
journal then exception will be throwed out and NULL will be returned.</p>

<p>See bellow "Filesystem API" topic for detailed description of the filesystem 
opening process.
</td></tr></table>

<h2>libreiserfs</h2>

<table width=90%><tr><td align=justify>
<p>Libreiserfs will consist of:</p>

<ul>
	<li>a number of plugins (disk-layout plugins, journal plugins, node plugins, etc)
	<li>plugins factory.
	<li>a number of API for every plugin (reiserfs_super_*, reiserfs_journal_*). For example, 
libreiserfs will be working with directory plugin via directory API.
	<li>the filesystem API, the tree API, blocks API.
	<li>a number of utilities (gauge, exceptions, tools).
	<li>memory allocation factory.
</ul>

<p>Every plugin will consists of a number of common routines for all plugins
and plugin-specific routines.</p>

<p>The common routines are following:</p>

<ul>
	<li>init() - initializing of an object instance (for example, journal).
	<li>create() - creating of an object on device.
	<li>done() - finalizing of given object instance. Freeing all internal structures.
	<li>check() - checking specified object for validness.
	<li>recover() - recovering of specified object.
</ul>

<p>See bellow for plugin-specific routines.</p>

<p>Additional API for every plugin is needed because plugins will be implemented in 
application-independent manner in order to be used by any software. Not just libreiserfs. 
So they will have only their own low-level functions for working with underlying 
filesystem abstract object (journal, node, item, etc). Besides, all plugins will 
operate on lowest abstraction level in libreiserfs and they can't modify objects 
which lie on higher level.</p>

<p>So we need some layer for working with plugins in libreiserfs. This layer will 
operate on the same abstraction level as filesystem API and will be able to modify 
its internal structures directly.</p>

<h3>Abstraction levels in libreiserfs.</h3>

<p>Libreiserfs is structured into several abstraction layers.
Main goal of an abstraction layer is to  correctly  handle all possible 
situations and let higher abstraction layer to know what was the result.</p>

<p>libreiserfs has got such abstraction levels:</p>

<ul>
	<li>lowest level: plugins, DAL.
	<li>middle level: wrappers for plugins (journal, allocator, oid allocator, etc).
	<li>higher level: filesystem (reiserfs_fs_open, reiserfs_fs_create, etc)
	<li>highest level: "master" project that is using libreiserfs.
</ul>

<p>In the case of an error, current abstraction layer issues error message, 
meaningful on this level, handles  error condition as much as possible 
(by means of "exceptions" see below) and returns error code to the higher 
layer.</p>

<p>For example, if journal layer (function reiserfs_journal_open) failed to 
read block from the device, it will handle error like this:</p>

<pre>
libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
	_("Reading block %lu failed."), blk);
return NULL;
</pre>
	
<p>and return error to the higher layer (filesystem layer) instead of initialized
journal instance.</p>

<p>Then file system layer should handle this error like this:</p>

<pre>
libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
    _("Failed to open journal."));
return NULL;
</pre>

<p>It issues error message, meaningful on it level and return NULL instead
initialized filesystem instance.</p>

<p>etc.</p>

<p>In the case when fatal exception occurs (an exception that causes impossibility 
to continue current operation) then control will be passed onto highest level (the 
level of "master" project). And than "master" project has to decide what it will be 
doing. Usually it's actions are following: report about exception and exit.</p>

<p>However more smart behavior may be implemented too.</p>
</td></tr></table>

<h3>Exceptions in libreiserfs.</h3>

<table width=90%><tr><td align=justify>
<p>Exceptions in libreiserfs are uniform way to handle errors. Contrary to 
some similarity in naming, they have nothing common with non-local exits in 
languages like C++. When using exceptions, control flow is still based 
on normal C return-and-check-error-code pattern.</p>

<p>After exception is raised (thrown) it is processed by exception handled 
(currently there is single global exception handler, adding ability to 
register local exception handlers for particular types of errors is simple).</p>

<p>Exception handling factory contains default exception handler and set 
of function for exception processing. Default exception handler just 
prints to the stderr a exception message and exception type (ERROR, 
WARNING, FATAL, NO_FEATURE, BUG). Default handler may be re-implemented 
and registered in libreiserfs by libreiserfs_exception_set_handler function.</p>

<p>Default exception handler looks like this:</p>

<pre>
static reiserfs_exception_option_t default_handler(reiserfs_exception_t *ex) {
	if (ex-&gt;type == EXCEPTION_BUG)
		 fprintf (stderr, _("A bug has been detected in libreiserfs. "
			  "Please email a bug report to umka@namesys.com containing the version (%s) "
			  "and the following message: "), VERSION);
	else
		 fprintf (stderr, "%s: ", libreiserfs_exception_type_string(ex-&gt;type));

	fprintf (stderr, "%s\n", ex-&gt;message);

	switch (ex-&gt;options) {
		 case EXCEPTION_OK:
		 case EXCEPTION_CANCEL:
		 case EXCEPTION_IGNORE:
			  return ex-&gt;options;
		 default: return EXCEPTION_UNHANDLED;
	}
}
</pre>

<p>As you can see, default handler is very simple. It just prints in system error
exception's message and returns exception's option to caller without additional
processing.</p>

<p>A front-end ("master project") may reimplement exception handler in order to add extra 
functionality to it. It may to ask user something. For example:</p>

<p><i>"Error: Can't read block 8193. (C)ancel, (R)etry?"</i></p>

<p>Or yet another behavior. Exception handler may emit all errors to system log. 
The exception handler behavior will depend on application.</p>

<p>Exception handling functions:</p>

<b>typedef reiserfs_exception_option_t (reiserfs_exception_handler_t)<br>
(reiserfs_exception_t *ex);</b>

<p>Type for exception handler function.</p>

<b>reiserfs_exception_option_t libreiserfs_exception_throw(reiserfs_exception_type_t type, <br>
reiserfs_exception_option_t opt, const char* message, ...)</b>

<p>Raises (throws) an exception. Exception contains type (ERROR, WARNING, etc), 
options (IGNORE, CANCEL, RETRY, etc) and error message with exception ID.</p>

<p>After exceptions factory has caught an exception, it passes the control onto 
exception handler. Then exception handler processes exception in some manner and 
returns result into calling function. Then calling function may decide what 
it has to do. And this decision will be based on result of processing of issued 
exception.</p>

<p>For example:<p>

<p>Here an exception handler that proposes user to make choose.</p>

<pre>
reiserfs_exception_option_t some_exception_handler(reiserfs_exception_t *ex) {
	char c;
	
	fprint(stderr, "%s.", ex-&gt;message);

	if (ex-&gt;option | EXCEPTION_YES)
		fprint(stderr, "(Y)es ");
	if (ex-&gt;option | EXCEPTION_NO)
		fprint(stderr, "(N)o ");
		
	if (ex-&gt;option | EXCEPTION_RETRY)
		fprint(stderr, "(R)etry ");
	if (ex-&gt;option | EXCEPTION_CANCEL)
		fprint(stderr, "(C)ancel ");

	fprint(stderr, "?\n");
	fflush(stderr);
		
	c = getchar();
	if (c == 'Y' || c == 'y')
		return EXCEPTION_YES;
	if (c == 'N' || c == 'n')
		return EXCEPTION_NO;

	return EXCEPTION_NO;
}
	
void some_function(void) {

	if (reading_block_failed) {
		reiserfs_exception_option_t opt = libreiserfs_exception_throw(EXCEPTION_ERROR, 
			EXCEPTION_RETRY | EXCEPTION_CANCEL, "Can't read block %lu.", 8193);

		/* Here we check selected by user option returned from exception handler. */
		if (opt == EXCEPTION_RETRY) {
			fprintf(stderr, "User has choosed RETRY\n");
			goto retry_reading_block;
		}	
		
		if (opt == EXCEPTION_CANCEL) {
			fprintf(stderr, "User has choosed CANCEL\n");
			goto cancel_reading_block;
		}	
	}
}
</pre>

<p>After "some_function" throw exception in manner showed above, user will see:</p>

<i>Error: Can't read block 8193. (R)etry, (C)ancel?</i>

<p>and will make choose what to do. Users choose will returns into exception handler
"some_exception_handler" and into calling function "some_function". Then "some_function"
will check returned value and will print into standard error user's choose and will
do something based on the user's choose. In the example above these actions are following:
retry to read block or exit.</p>

<p>Value, returned by "libreiserfs_exception_throw" function may be one of the 
following:</p>

<ul>
	<li>EXCEPTION_UNHANDLED - exception has been not processed.
	<li>EXCEPTION_YES - exception has been processed and user has selected "yes" 
	from suggested choice.
	<li>EXCEPTION_NO - exception has been processed and user has selected "no" 
	from suggested choice.
	<li>EXCEPTION_OK - exception has been processed and user has selected "ok" 
	from suggested choice.
	<li>EXCEPTION_RETRY - exception has been processed and user has selected "retry" 
	from suggested choice.
	<li>EXCEPTION_IGNORE - exception has been processed and user has selected "ignore" 
	from suggested choice.
	<li>EXCEPTION_CANCEL - exception has been processed and user has selected "cancel" 
	from suggested choice.
</ul>

<p>The default exception handler returns one of values that was ordered in second 
parameter of "libreiserfs_exception_throw" function.</p>

<b>reiserfs_exception_option_t libreiserfs_exception_rethrow(void)</b>

<p>Re-throws last exception.</p>

<b>void libreiserfs_exception_catch(void)</b>

<p>Releases exception.</p>

<b>void libreiserfs_exception_fetch_all(void)</b>

<p>Disables exceptions: force exception handler to just return. It is useful for implementing
few debug levels in the "master" project. It may be disabling all exceptions for some 
operations. For example:</p>

<pre>
int main (int argc, char *argv[]) {
	reiserfs_fs_t *fs = reiserfs_fs_open(dal, dal);

	libreiserfs_exception_fetch_all();

	<i>Doing something with opened filesystem. Exception handler will not be called.</i>

	libreiserfs_exception_leave_all();

	reiserfs_fs_close(fs);
}
</pre>

<b>void libreiserfs_exception_leave_all(void)</b>

<p>Enables exceptions: switches back to normal handler behavior. See above for usage.</p>
</td></tr></table>

<h3>Gauge API.</h3>

<table width=90%><tr><td align=justify>
<p>libreiserfs includes so called gauge API. It is the mechanism to handle 
progress activities by "master" project. This mechanism is based on "gauge_handler" 
callback function that may be installed by "master" project. So, progress 
presentation may be changed by installing other handler than the default handler.</p>

<p>Gauge API consists of the following routines and types:</p>

<b>typedef (*reiserfs_gauge_handler_t) (const char *, unsigned int, void *, int, int, int)</b>

<p>Type of gauge callback function. Gauge callback function accepts following 
parameters:</p>
<ul>
	<li>description on the current progress. For example, "Initializing journal".
	<li>current percentage.
	<li>gauge specific data.
	<li>gauge kind (may be changed online)
	<li>the flag ("bool" value) that shows whether gauge handler must update gauge header 
	(description).
	<li>the flag ("bool" value) that shows whether gauge handler must update gauge footer.
</ul>

<b>reiserfs_gauge_t *reiserfs_gauge_create(const char *name,<br>
reiserfs_gauge_handler_t handler, void *data)</b>

<p>Creates new gauge instance and sets it up with passed parameters.</p>

<b>void libreiserfs_gauge_free(reiserfs_gauge_t *gauge)</b>

<p>Frees all gauge associated memory.</p>

<b>void libreiserfs_gauge_reset(reiserfs_gauge_t *gauge)</b>

<p>Resets given gauge value into zero.</p>

<b>void libreiserfs_gauge_enable(reiserfs_gauge_t *gauge),<br>
void libreiserfs_gauge_disable(reiserfs_gauge_t *gauge)</b>

<p>Enables/disables given gauge. In the case gauge was disabled, installed gauge handler 
will not be called, until gauge will be enabled.</p>

<b>void libreiserfa_gauge_set_handler(reiserfs_gauge_t *gauge,<br>
reiserfs_gauge_handler_t *handler)</b>

<p>Set up new gauge handler.</p>

<b>reiserfs_gauge_handler_t *libreiserfs_gauge_handler(reiserfs_gauge_t *gauge)</b>

<p>Returns current gauge handler.</p>

<b>void libreiserfs_gauge_set_data(reiserfs_gauge_t *gauge, void *data)<br>
void *libreiserfs_gauge_data(reiserfs_gauge_t *gauge)</b>

<p>Setting up and getting of gauge-specified data.</p>

<b>void libreiserfs_gauge_set_name(reiserfs_gauge_t *gauge, const char *name)<br>
char *libreiserfs_gauge_name(reiserfs_gauge_t *gauge)</b>

<p>Setting up and getting of gauge's name (description).</p>

<b>void libreiserfs_gauge_set_value(reiserfs_gauge_t *gauge, unsigned int value)<br>
unsigned int libreiserfs_gauge_name(reiserfs_gauge_t *gauge)</b>

<p>Setting up and getting of gauge's current percentage.</p>

<b>void libreiserfs_gauge_touch(reiserfs_gauge_t *gauge)</b>

<p>Updates given gauge. In fact gauge handler is calling in this point.</p>

<b>void reiserfs_gauge_done(reiserfs_gauge_t *gauge)</b>

<p>Calls gauge handler with turned on "update_footer" flag. In this point gauge handler may 
print into standard error "done", meaning that long operation is finished.</p>

<p>For example, simple gauge will roughly look like:</p>

<p>The first function bellow is gauge handler. It will be "drawing" the gauge into 
standard error.</p>
	
<pre>
static void progs_gauge_handler(const char *name, unsigned int value, void *data,
	int determined, int update_header, int update_footer)
{
	if (update_header) fputs(name);
		
	sprintf(display, "%d%%", value);
	fputs(display, stderr);
	fputc('\b', stderr);
	
	if (update_footer) fputs("done\n");
		
	fflush(stderr);
}

int main(int argc, char *argv[]) {
	reiserfs_gauge_t *gauge = libreiserfs_gauge_create("Test long operation", gauge_handler, 
		NULL);
	
	int percentage = 0;
	
	for (; percentage &lt; 100; i++)
		libreiserfs_gauge_set_value(percentage);

	libreiserfs_gauge_done(gauge);	
		
	libreiserfs_gauge_free(gauge);
	return 0;
}
</pre>

<p>Gauge will look like this:</p>

<p><b>"Test long operation: 35%"</b></p>

<p>After long operation will be done and libreiserfs_gauge_done will be called, 
progress information will looks like this:</p>

<p><b>"Test long operation: done"</b></p>

<p>etc.</p>
</td></tr></table>

<h3>Memory allocation.</h3>
<table width=90%><tr><td align=justify>
<p>In order to used libreiserfs in boot-loaders (Yaboot, GNU GRUB, etc), which 
are working without libc and kernel, and can't use standard memory allocation factory,
libreiserfs should have a mechanism for using memory allocation functions which are
actually implemented by its "master" project (some bootloader in this case). As usual, 
a project oriented to be working alone (without libc and kernel) has its own memory 
management subsystem. Therefore, libreiserfs must be able to use that subsystem.</p>

<p>This mechanism is based on installable memory-allocation functions, which 
will be called for every time, when memory will be allocated on freed in libreiserfs.</p>

<p>There are following:</p>

<b>typedef void *(*libreiserfs_malloc_handler_t) (size_t)</b>

<p>Type for memory allocation handler.</p>

<b>typedef void *(*libreiserfs_realloc_handler_t) (void *, size_t)</b>

<p>Type for memory reallocation handler.</p>

<b>typedef void (*libreiserfs_free_handler_t) (void *)</b>

<p>Type for memory freeing handler.</p>

<b>void libreiserfs_malloc_set_handler(libreiserfs_malloc_handler_t handler)</b>

<p>Sets handler for memory allocation purposes. By default it is "malloc()" function
from corresponding libc.</p>

<b>libreiserfs_malloc_handler_t libreiserfs_malloc_handler(void)</b>

<p>Gets current memory allocation handler.</p>

<b>void *libreiserfs_malloc(size_t size)</b>

<p>Allocates memory chunk of specified size and returns pointer to it to caller.
Current memory allocation handler is used to allocate memory.</p>

<b>void *libreiserfs_calloc(size_t size, char c)</b>

<p>Allocates memory chunk of specified size, fills it by given character and returns its to
caller.</p>

<b>void libreiserfs_realloc_set_handler(libreiserfs_realloc_handler_t handler)</b>

<p>Sets handler for memory reallocation purposes. By default it is "realloc()" function
from corresponding libc.</p>

<b>libreiserfs_realloc_handler_t libreiserfs_realloc_handler(void)</b>

<p>Gets current memory reallocation handler.</p>

<b>int libreiserfs_realloc(void** old, size_t size)</b>

<p>Reallocates specified memory chunk for given size, using current reallocation handler.</p>

<b>void libreiserfs_free_set_handler(libreiserfs_free_handler_t handler)</b>

<p>Sets handler for memory freeing purposes. By default it is "free()" function from
corresponding libc.</p>

<b>libreiserfs_free_handler_t libreiserfs_free_handler(void)</b>

<p>Gets current freeing handler.</p>

<b>void libreiserfs_free(void* ptr)</b>

<p>Frees specified memory chunk using current freeing handler.</p>

<p>For example, Milo bootloader may be using libreiserfs' memory allocation factory 
roughly like this:</p>

<pre>
void *milo_malloc(size_t size) {
	/* Some actions */
	...
	
	return mem;
}

void *milo_realloc(void *ptr, size_t size) {
	/* Some actions */
	...
	
	return mem;
}

void milo_free(void *ptr) {
	/* Some actions */
	...
}

void milo_libreiserfs_init() {
	libreiserfs_malloc_set_handler(milo_malloc);
	libreiserfs_realloc_set_handler(milo_malloc);
	libreiserfs_free_set_handler(milo_malloc);
}
</pre>

</td</tr></table>

<h3>String-working functions. Memory-working functions.</h3>

<table width=90%><tr><td align=justify>
<p>As libreiserfs will be used by boot-loaders or any other applications which 
are working alone (without libc), we need to reimplement in libreiserfs some 
string-working functions and memory-working functions which are used by libreiserfs.</p>

<p>Using of our own implementation of memory-working functions and string-working 
functions will be activated by including "-nostdlib" option into linking parameters. 
By default, will be used standard functions.</p>

<p>Memory-working functions will be following:<br>
memcpy(), memset(), memcmp(), memmove()</p>

<p>For example, memcpy function may be look:</p>

<pre>
void *memcpy(void *dest, const void *src, size_t n) {
	char *dest_p = (char *)dest; char *src_p = (char *)src;

	for (; (int)src_p - (int)src &lt; n; src_p++, dest_p++)
		*destp = *srcp;

	return dest;
}
</pre>

<p>String working functions will be using memory-working functions and will be following:<br>
strlen(), strcmp(), strncmp(), strncat(), strchr().
</p>

<p>Reasons why libreiserfs should implement these functions:</p>

<ul>
	<li>usually these functions are not implemented in "alone" applications at 
	all or implemented in minimal manner. Implemented set is not quite sufficient 
	for libreiserfs.
	<li>all "alone" applications should implement these functions in order to use libreiserfs.
	This is an additional requirement for using libreiserfs and this requirement makes using 
	of libreiserfs more complex. Because of this additional requirement, some projects may
	decline to use libreiserfs.
</ul>

<p>Or we may follow yet another way. This way is to delegate implementation of these 
functions to the "master" project.</p>

<p>Reasons why libreiserfs doesn't have to implement these functions.</p>

<ul>
	<li>implementation of these functions in libreiserfs blows libreiserfs code up.
	<li>bad portability.
</ul>

</td</tr></table>
	
<h3>Filesystem API.</h3>

<table width=90%><tr><td align=justify>
<p>Filesystem API will be containing all public functions.</p>

<p>There are general functions:<br>
reiserfs_fs_open, reiserfs_fs_close, reiserfs_fs_resize, reiserfs_fs_copy, 
reiserfs_fs_check, etc.</p>

<p>And some utilities:<br>
reiserfs_fs_format, reiserfs_fs_uuid, reiserfs_fs_lable,
reiserfs_fs_size, reiserfs_fs_metadata_size, etc.</p>

<p>In order to work with some filesystem, it must be first opened (mounted) by 
"reiserfs_fs_open" call. After filesystem has been opened, we can access its properties 
and methods. And at the end, filesystem be must closed by "reiserfs_fs_close" function.</p>

<p>Opening of a filesystem consists of the following steps:</p>

</p>initialize all internal structures; read superblock, and journal header; 
replay journal; check journal header for validness; re-read superblock from 
the journal (if it was overwritten by journal replay); check superblock for 
validness; optionally initialize allocator and check it for validness; initialize tree; 
read the root block, and check it for validness; return initialized filesystem instance.</p>

<p>And closing will include such actions: syncing, calling "close" for all filesystem objects 
(journal, oid allocator, allocator, etc), freeing all internal structures.</p>

<p>After a filesystem was opened by "reiserfs_fs_open" function, returned descriptor 
may be used to work with corresponding filesystem. It may be resized, copied, tuned, etc.
Also filesystem may be checked for errors on it. Checking for errors on the underlying 
filesystem may be performed by "reiserfs_fs_check" function. This function may perform
basic checks or more complex checks or even tree-rebuilding.
</p>

<p>Filesystem initialization (opening) and closing will roughly look like:</p>

<pre>
struct reiserfs_fs {
	dal_t *dal;

	reiserfs_tree_t *tree;
	reiserfs_super_t *super;
	reiserfs_oid_t *oid;
	reiserfs_alloc_t *alloc;
	reiserfs_journal_t *journal;

	uint16_t flags;
};

reiserfs_fs_t *reiserfs_fs_open(dal_t *host_dal, dal_t *journal_dal) {
	blk_t root_block;
	reiserfs_fs_t *fs;
	blk_t journal_block;

	uint16_t alloc_plug_id;
	uint16_t journal_plug_id;

	ASSERT(host_dal != NULL, return NULL);
	ASSERT(journal_dal != NULL, return NULL);

	if (!(fs != libreiserfs_calloc(sizeof(*fs), 0)))
		 return NULL;

	if (!(fs-&gt;super = reiserfs_super_open(host_dal))) {
		 libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			  _("Couldn't open superblock."));
		 goto error_free_fs;
	}

	journal_plug_id = super-&gt;layout_plug-&gt;u.layout.journal_plug_id();
	journal_block = super-&gt;layout_plug-&gt;u.get_journal_block();
	if (!(fs-&gt;journal = reiserfs_journal_open(journal_dal, journal_block, journal_plug_id))){
		 libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			  _("Couldn't open journal."));
		 goto error_free_super;
	}

	alloc_plug_id = super-&gt;layout_plug-&gt;u.layout.alloc_plug_id();
	if (!(fs-&gt;alloc = reiserfs_alloc_open(alloc_plug_id))) {
		libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			 _("Couldn't open allocator"));
		goto error_free_journal
	}

	oid_plug_id = super-&gt;layout_plug-&gt;u.layout.oid_plug_id();
	if (!(fs-&gt;oid = reiserfs_oid_open(oid_plug_id))) {
		libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			_("Couldn't open oid allocator."));
		goto error_free_alloc;
	}

	root_block = super-&gt;layout_plug-&gt;u.layout.get_root_block();
	if (!(fs-&gt;tree = reiserfs_tree_open(root_block))) {
		libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			  _("Couldn't open tree."));
		goto error_free_oid;
	}

	return fs;
	
error_free_oid:
	reiserfs_oid_close(fs);
error_free_alloc:
	reiserfs_alloc_close(fs);
error_free_journal:
	reiserfs_journal_close(fs);
error_free_super:	
	reiserfs_super_close(fs);
error_free_fs:
	libreiserfs_free(fs);
error:
	return NULL;
}

void reiserfs_fs_close(reiserfs_fs_t *fs) {
	reiserfs_journal_close(fs-&gt;journal);
	reiserfs_super_close(fs-&gt;super);
	reiserfs_alloc_close(fs-&gt;alloc);
	reiserfs_tree_close(fs-&gt;alloc);
	libreiserfs_free(fs);
}
</pre>

<p>See bellow, for detailed journal and super-block code.</p>
</td></tr></table>

<h3>Journal plugin. Journal API.</h3>

<table width=90%><tr><td align=justify>
<p>Reiser4 will support several formats of the journal. In order to support 
various format of journal we need the journal 
plugin.</p>

<p>Opening (initialization) of the journal  will include reading the journal header,
checking it for validness. Possibly it will build journal cache, or something else. 
The journal behavior fully depends on the journal plugin. Then journal plugin will 
prepare initialized journal instance and will return it to caller.</p>

<p>Journal plugin interface will depends on common journal parameters for every journal 
format. As reiser4 should support old journal format, journal plugin must export interface 
to obtain such parameters: start, length, max_trans_size, etc. Also interface must let 
to do something with the journal (tuning, resizing, etc).</p>

<p>Journal plugin will consist of two main parts:</p>

<ul>
	<li>common part (the part that will exist in all formats).
	<li>deprecated part (the part that is needed by reiser3 journal format).
</ul>

<p>Journal plugin will roughly look like:</p>

<pre>
typedef void reiserfs_journal_opaque_t;

struct reiserfs_journal_plug {
	reiserfs_journal_opaque_t *(*init) (dal_t *dal);
	reiserfs_journal_opaque_t *(*create) (dal_t *dal, some_format_specific_parameters);
	void (*done) (reiserfs_journal_opaque_t *);

	int (*check) (reiserfs_journal_opaque_t *);
	int (*recover) (reiserfs_journal_opaque_t *);

	/* Journal routines which are common in reiser3 and reiser4 journal format */
	int (*replay) (reiserfs_journal_opaque_t *, int is_replay);
	int (*alterable) (reiserfs_journal_opaque_t *);
	int (*switch) (dal_t *dal);

	/* Deprecated part. Needed for reiser3 journal format. */
	blk_t (*get_start) (reisrefs_journal_opaque_t *);
	void (*set_start) (reiserfs_journal_opaque_t *, blk_t start);
	
	blk_t (*get_len) (reisrefs_journal_opaque_t *);
	void (*set_len) (reiserfs_journal_opaque_t *, blk_t len);
	
	blk_t (*get_max_trans) (reisrefs_journal_opaque_t *);
	void (*set_max_trans) (reiserfs_journal_opaque_t *, blk_t max_trans);
};
</pre>

<b>reiserfs_journal_opaque_t *(*init) (dal_t *dal)</b>

<p>Opens journal (reading the header and checking it for errors) and returns
initialized journal instance. This instance will be used to work with journal.</p>

<b>reiserfs_journal_opaque_t *(*create) (dal_t *dal, some_format_specific_parameters)</b>

<p>Creates the journal on specified DAL. Opens created journal by "init" call
and returns initialized journal instance.</p>

<b>void (*done) (reiserfs_journal_opaque_t *)</b>

<p>Closes journal. Frees all internal structures.</p>

<b>int (*check) (reiserfs_journal_opaque_t *)</b>

<p>Checks the journal for validness. Returns result of checking: "true" on success
or "false" on failure.</p>

<b>int (*recover) (reiserfs_journal_opaque_t *)</b>

<p>Makes recovering of the journal. Returns result of recovering: "true" on success
or "false" on failure.</p>

<b>int (*replay) (reiserfs_journal_opaque_t *, int is_replay)</b>

<p>Replays journal. Returns result of replaying.</p>

<b>int (*alterable) (reiserfs_journal_opaque_t *)</b>

<p>Returns "bool" value that means whether journal can be resized, tuned or not.</p>

<b>int (*switch) (dal_t *dal)</b>

<p>Switches journal onto specified device. Returns "true" on success
or "false" on failure.</p>

<b>blk_t (*get_start) (reisrefs_journal_opaque_t *)<br>
void (*set_start) (reiserfs_journal_opaque_t *, blk_t start)</b>

<p>Gets/sets journal start for reiser3 journal format.</p>

<b>blk_t (*get_len) (reisrefs_journal_opaque_t *)<br>
void (*set_len) (reiserfs_journal_opaque_t *, blk_t len)</b>

<p>Gets/sets journal length for reiser3 journal format. "set_len" and "set_start" 
routines will be used for journal resizing in reiser3.</p>
	
<b>blk_t (*get_max_trans) (reisrefs_journal_opaque_t *)</b>
<b>void (*set_max_trans) (reiserfs_journal_opaque_t *, blk_t max_trans)</b>

<p>Gets/sets "max_trans_size" value for reiser3 journal.</p>

<p>Journal API will be a set of wrapper functions for journal plugin. 
There following: reiserfs_journal_create, reiserfs_journal_open,
reiserfs_journal_close, reiserfs_journal_replay, reiserfs_journal_resize, 
etc.</p>

<p>Also journal API will contain common code for all journal formats.</p>

<pre>
struct reiserfs_journal {
	dal_t *dal;
	reiserfs_journal_opaque_t *journal_instance;
	reiserfs_plug_t *journal_plug;
};

typedef struct reiserfs_journal reiserfs_journal_t;
</pre>

<b>dal_t *dal</b>

<p>DAL of device where journal lies.</p>

<b>reiserfs_journal_opaque_t *journal_instance</b>

<p>Pointer to initialized journal instance. Will be used later to interact with
underlying journal.</p>

<b>reiserfs_plug_t *journal_plug</b>

<p>Journal format plugin.</p>

<p>Journal open and close will roughly look like:</p>

<pre>
reiserfs_journal_t *reiserfs_journal_open(dak_t *dal, blk_t journal_block,
	uint16_t journal_plug_id)
{
	reiserfs_journal_opaque_t *journal_instance;
	reiserfs_journal_t *journal;
	reiserfs_plug_t *journal_plug;

	if (!(journal_plug = reiserfs_plug_load(REISERFS_PLUG_JOURNAL, journal_plug_id)))
		 return NULL;

	if (!(journal_instance = journal_plug-&gt;u.journal.init(dal))) {
		 libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			  _("Couldn't initialize journal."));
		 return NULL;
	}

	if (!(journal = libreiserfs_calloc(sizeof(*journal), 0)))
		 goto error_free_journal_instance;
	
	journal-&gt;journal_block = journal_block;
	journal-&gt;journal_plug = journal_plug;
	journal-&gt;journal_instance = journal_instance;

	/* Optional journal replaying */

	return journal;

error_free_journal_instance:
	libreiserfs_free(journal_instance);
error:
	return NULL;
}

void reiserfs_journal_close(reiserfs_journal_t *journal) {
	ASSERT(journal != NULL, return);

	journal-&gt;journal_plug-&gt;u.journal-&gt;done(journal-&gt;journal_instance);
	reiserfs_plug_unload(journal-&gt;journal_plug);
	libreiserfs_free(journal);
}
</pre>
</td></tr></table>

<h3>Disk-Format (Disk-Layout) plugin. Superblock API.</h3>

<table width=90%><tr><td align=justify>
<p>Disk-Format plugin defines following components of the filesystem:</p>
		
<ul>
	<li>superblock location.
	<li>root block location.
	<li>journal plugin.
	<li>oid allocator plugin.
</ul>

<p>As opening of a filesystem directly depends on disk-format, all available 
disk-format plugins must be loaded during library initialization time, just after 
plugin cache will be initialized in order to be able to find any superblock at 
filesystem opening time. Or they might be loaded on first attempt to open a 
filesystem.</p>

<p>Disk-Format plugin will look like:</p>

<pre>
typdef void reiserfs_layout_opaque_t;
	
struct reiserfs_layout_plug {
	reiserfs_layout_opaque_t *(*init) (dal_t *);
	reiserfs_layout_opaque_t *(*create) (dal_t *, some_format_specific_parameters);
	void (*done) (reiserfs_layout_opaque_t *);

	int (*check) (reiserfs_layout_opaque_t *);
	int (*recover) (reiserfs_layout_opaque_t *);

	reiserfs_key_t *(*get_rootdir_key) (reiserfs_layout_opaque_t *); 
	
	uint16_t (*alloc_plug_id) (reiserfs_layout_opaque_t *);
	uint16_t (*oid_plug_id) (reiserfs_layout_opaque_t *);
	uint16_t (*journal_plug_id) (reiserfs_layout_opaque_t *);

	/* Routines for working with superblock */
	blk_t (*get_journal_block) (reiserfs_layout_opaque_t *);
	void (*set_journal_block) (reiserfs_layout_opaque_t *, blk_t);

	blk_t (*get_block_count) (reiserfs_layout_opaque_t *);
	void (*set_block_count) (reiserfs_layout_opaque_t *, blk_t);

	blk_t (*get_free_blocks) (reiserfs_layout_opaque_t *);
	void (*set_free_blocks) (reiserfs_layout_opaque_t *, blk_t);

	blk_t (*get_root_block) (reiserfs_layout_opaque_t *);
	void (*set_root_block) (reiserfs_layout_opaque_t *, blk_t);

	uint16_t (*get_tree_height) (reiserfs_layout_opaque_t *);
	void (*set_tree_height) (reiserfs_layout_opaque_t *, uint32_t);

	uint64_t (*get_file_count) (reiserfs_layout_opaque_t *);
	void (*set_file_count) (reiserfs_layout_opaque_t *, uint64_t);
};

typedef struct reiserfs_layout_plug reiserfs_layout_plug_t;
</pre>

<b>reiserfs_layout_opaque_t *(*init) (dal_t *)</b>

<p>Opens disk-layout. Initializes internal plugins structures and returns
layout opaque instance to caller.</p>

<b>reiserfs_layout_opaque_t *(*create) (dal_t *, some_format_specific_parameters)</b>

<p>Creates superblock on specified device.</p>

<b>void (*done) (reiserfs_layout_opaque_t *)</b>

<p>Closes specified disk-layout instance. Frees all its internal structures.</p>

<b>int (*check) (reiserfs_layout_opaque_t *)</b>

<p>Makes checking for validness of disk-layout. It is check for validness 
of superblock, right location of root node, etc.</p>

<b>int (*recover) (reiserfs_layout_opaque_t *)</b>

<p>Makes recovering of the disk-layout. Returns result of recovering: "true" 
on success or "false" on failure.</p>

<b>uint16_t (*alloc_plug_id) (reiserfs_layout_opaque_t *)</b>

<p>Returns allocator plugin (space allocator) identifier.</p>

<b>uint16_t (*oid_plug_id) (reiserfs_layout_opaque_t *)</b>

<p>Returns oid allocator plugin's ID. Will be used in order to find oid 
allocator plugin in plugins cache and plugin map.</p>

<b>uint16_t (*journal_plug_id) (reiserfs_layout_opaque_t *)</b>

<p>Returns journal plugin identifier. Will be used in order to find
needed journal plugin.</p>

<b>reiserfs_key_t *(*get_rootdir_key) (reiserfs_layout_opaque_t *)</b>

<p>Returns root directory key.</p>

<b>blk_t (*get_journal_block) (reiserfs_layout_opaque_t *)<br>
reiserfs_layout_opaque_t(*set_journal_block) (reiserfs_layout_opaque_t *, blk_t)</b>

<p>Gets/sets the block where journal header is lies.</p>

<b>blk_t (*get_block_count) (reiserfs_layout_opaque_t *)<br>
reiserfs_layout_opaque_t(*set_block_count) (reiserfs_layout_opaque_t *, blk_t)</b>

<p>Gets/sets  "block_count" field of super block of this layout.</p>

<b>blk_t (*get_free_blocks) (reiserfs_layout_opaque_t *)<br>
reiserfs_layout_opaque_t(*set_free_blocks) (reiserfs_layout_opaque_t *, blk_t)</b>

<p>Gets/sets "free_blocks" field of super block of this  layout.</p>

<b>blk_t (*get_root_block) (reiserfs_layout_opaque_t *)<br>
reiserfs_layout_opaque_t(*set_root_block) (reiserfs_layout_opaque_t *, blk_t)</b>

<p>Gets/sets "root_block"  field of super block of this layout.</p>

<b>uint16_t (*get_tree_height) (reiserfs_layout_opaque_t *)<br>
reiserfs_layout_opaque_t(*set_tree_height) (reiserfs_layout_opaque_t *, uint16_t)</b>

<p>Gets/sets field "tree_height" of super block of this  layout.</p>

<b>uint64_t (*get_file_count) (reiserfs_layout_opaque_t *) <br>
reiserfs_layout_opaque_t(*get_file_count) (reiserfs_layout_opaque_t *, uint64_t)</b>

<p>Gets/sets "file_count" of super block of this layout.</p>

<p>Superblock API will be a set of wrapper functions for disk-layout plugin.
It will include the following: reiserfs_super_open, reiserfs_super_close, 
reiserfs_super_update_magic, etc.</p>

<pre>
struct reiserfs_super {
	reiserfs_layout_opaque_t *layout_instance;
	reiserfs_plug_t *layout_plug;
};

typedef struct reiserfs_super reiserfs_super_t;
</pre>

<b>reiserfs_plug_t *layout_plug</b>

<p>The pointer to layout_plugin</p>

<b>reiserfs_layout_opaque_t *layout_instance</b>

<p>Pointer to initialized instance of some layout. Will be used later
to work with that layout.</p>

<p>Superblock opening and closing routines will roughly look like:</p>

<pre>
reiserfs_super_t *reiserfs_super_open(dal_t *dal) {
   	int i;
  	reiserfs_super_t *super;
   	reiserfs_layout_opaque_t *layout_instance = NULL;
   	reiserfs_plug_t *layout_plug = NULL;

	for (i = 0; i &lt; plug_count; i++) {
	   	if (plugs[i]-&gt;plug_kind != REISERFS_PLUG_DISK_LAYOUT)
		  	continue;

	   	if ((layout_instance = plugs[i]-&gt;u.layout.init(dal))) {
			layout_plug = plugs[i];
			break;
	   	}
	}

	if (!layout_plug) {
		libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			_("Couldn't find any disk layout."));
		return NULL;
	}

	if (!(super = libreiserfs_calloc(sizeof(*super), 0)))
		return NULL;

	super-&gt;layout_plug = layout_plug;
	super-&gt;layout_instance = layout_instance;

	return super;
}

void reiserfs_super_close(reiserfs_super_t *super) {
	ASSERT(super != NULL, return);

	super-&gt;layout_plug-&gt;u.layout-&gt;done(super-&gt;layout_instance);

	libreiserfs_free(journal);
}
</pre>
</td></tr></table>

<h3>Allocator plugin. Allocator API.</h3>

<table width=90%><tr><td align=justify>
<p>A replica of bitmap in reiser3. Allocator plugin will roughly look like:</p>

<pre>
typedef void reiserfs_alloc_opaque_t;

struct reiserfs_segment {
	blk_t start, end;
};

typedef struct reiserfs_segment reiserfs_segment_t;

struct reiserfs_alloc {
	reiserfs_alloc_opaque_t *(*init) (dal_t *);
	reiserfs_alloc_opaque_t *(*create) (dal_t *);
	void (*done) (reiserfs_alloc_opaque_t *);

	int (*check) (reiserfs_alloc_opaque_t *);
	int (*recover) (reiserfs_alloc_opaque_t *);
	
	int (*allocate) (reiserfs_alloc_opaque_t *, size_t blocks, reiserfs_segment_t *);
	int (*deallocate) (reiserfs_alloc_opaque_t *, reiserfs_segment_t *);
};

typedef struct reiserfs_alloc reiserfs_alloc_t;
</pre>

<b>reiserfs_alloc_opaque_t *(*init) (dal_t *)</b>

<p>Initializes allocator on specified device. Returns initialized allocator opaque
instance.</p>

<b>reiserfs_alloc_opaque_t *(*create) (dal_t *)</b>

<p>Creates allocator on specified device. Returns initialized allocator opaque
instance.</p>

<b>void (*done) (reiserfs_alloc_opaque_t *)</b>

<p>Frees all allocator internal structures.</p>

<b>int (*check) (reiserfs_alloc_opaque_t *)</b>

<p>Makes checking for validness of the allocator.</p>

<b>int (*recover) (reiserfs_alloc_opaque_t *)</b>

<p>Makes recovering of the allocator.</p>

<b>int (*allocate) (reiserfs_alloc_opaque_t *, size_t blocks, reiserfs_segment_t *)</b>

<p>Allocates "blocks" number of blocks, fills reiserfs_segment_t struct by start
of allocated region and its end and returns result of operation to caller.</p>

<b>int (*deallocate) (reiserfs_alloc_opaque_t *, reiserfs_segment_t *)</b>

<p>Deallocates specified segment.</p>
</td></tr></table>

<h3>Balanced Tree API.</h3>

<table width=90%><tr><td align=justify>
<p>There are functions to work with b*tree. There are following:</p>

<b>reiserfs_tree_t *reiserfs_tree_open(reiserfs_fs_t *fs)</b>

<p>Opens balanced tree on the specified filesystem. It reads root block, checks it for 
validness, allocates reiserfs_tree_t instance and returns it to caller. This function 
is called by reiserfs_fs_open function.</p>

<b>reiserfs_tree_t *reiserfs_tree_create(reiserfs_fs_t *fs)</b>

<p>Create balanced tree on the specified filesystem. It composes the root block of the 
tree, and stores it on "host_dal" device of given filesystem. Also allocates 
reiserfs_tree_t instance and returns it to caller. This function is used during 
filesystem creation by reiserfs_fs_create function.</p>

<b>void reiserfs_tree_t *reiserfs_tree_close(reiserfs_tree_t *tree)</b>

<p>Frees all memory associated with tree and optionally syncs the root node of the 
tree.</p>

<b>int reiserfs_tree_lookup_internal(reiserfs_tree_t *tree, blk_t from, <br>
reiserfs_comp_func_t *comp_func, struct key *key, reiserfs_path_t *path)</b>

<p>Looks up for specified key in the balanced tree. Stops search on the found 
internal node on the second level. Fills "path" by tracked path. For comparing keys 
"comp_func" callback function is used. "reiserfs_tree_lookup_internal" function is 
used by tree modification routines in order to find the internal node we should 
insert new formated node in.</p>

<b>int reiserfs_tree_lookup_leaf(reiserfs_tree_t *tree, blk_t from, <br>
reiserfs_comp_func_t *comp_func, struct key *key, reiserfs_path_t *path)</b>

<p>Looks up for specified key in the balanced tree. Stops search on the found 
leaf node. Fills "path" by tracked path. For comparing keys "comp_func" callback 
function is used. It is used by tree modification routines in order to find the leaf in 
the tree and the position inside found leaf where we should insert new item. It is 
also used by file and directory APIs.</p>

<b>long reiserfs_tree_traverse(reiserfs_tree_t *tree, void *data,<br>
reiserfs_edge_traverse_func_t before_node_func, reiserfs_node_func_t node_func,<br>
reiserfs_chld_func_t chld_func, reiserfs_edge_traverse_func_t after_node_func)</b>

<p>Makes full traversing in the balanced tree. It uses a set of callback functions 
for all "node-specific" operations for every formated node. Traversing may be stopped 
in any point if a callback function returns "bool" false value.</p>

<p>This is the central function for all following operations:</p>

<p>resizing, smart resizing (resize filesystem by start and end parameters), copying, 
relocating (relocates specified region of the balanced tree onto other specified region), 
journal resizing, journal relocating, etc.</p>

<b>int reiserfs_tree_insert_node(reiserfs_tree_t *tree, reiserfs_node_t *node)</b>

<p>Inserts previously composed node into the tree corresponding to its key. 
Returns result of operation: "true" on success or "false" on failure.</p>

<b>int reiserfs_tree_insert_item(reiserfs_tree_t *tree, reiserfs_item_t *item)</b>

<p>Inserts specified item into the tree by item's key. Returns result of operation: 
"true" on success or "false" on failure.</p>

<b>int reiserfs_tree_delete_node(reiserfs_tree_t *tree, reiserfs_key_t *key)</b>

<p>Removes node that contains specified key from the tree. Returns result of operation: 
"true" on success or "false" on failure.</p>

<b>int reiserfs_tree_delete_item(reiserfs_tree_t *tree, reiserfs_key_t *key)</b>

<p>Removes item by specified key from the tree. Returns result of operation: "true" on success 
or "false" on failure.</p>

<p>There will be also a number of functions to work with items: delete unit, 
insert unit, etc (cut and paste operations in reiser3).</p>
</td></tr></table>

<h3>Plugins map.</h3>

<table width=90%><tr><td align=justify>
<p>Plugins map keeps correspondence between plugin's cords (KIND, ID) and shared library for 
this plugin.<br>For example, (kind: 0x01, type: 0x01) == (libjournal40.so)</p>
</td></tr></table>

<h3>Plugins factory.</h3>

<table width=90%><tr><td align=justify>
<p>On the initialization time libreiserfs will initialize plugins factory 
with plugins cache that will store loaded plugins. Plugin cache keeps track 
of loaded plugins and allows to avoid duplicate loading of the same plugin.</p>

<p>For example, during filesystem open library will determine what journal 
plugin to use. Corresponding plugin will be located, loaded and stored in the 
cache. After that, filesystem open will proceed further.</p>

<p>All other plugins will be loaded on demand and stored in plugin cache. And 
all subsequent requests to load the same plugin will be satisfied from the cache.
It is mean that plugins will be in separate files (shared library).</p>

<p>Plugins loading code and data-structures look roughly like following:</p>

<pre>
#define REISERFS_PLUG_MAX_NAME  255
#define REISERFS_PLUG_MAX_DESC  255

#define REISERFS_PLUG_MAX_KIND  255
#define REISERFS_PLUG_MAX_TYPE  255

extern reiserfs_plug_t *plug_cashe[REISERFS_PLUG_MAX_KIND][REISERFS_PLUG_MAX_TYPE];

enum reiserfs_plug_kind {
	REISERFS_PLUG_JOURNAL       = 1 &lt;&lt; 0,
	REISERFS_PLUG_DIR           = 1 &lt;&lt; 1,
	REISERFS_PLUG_FILE          = 1 &lt;&lt; 2,
	REISERFS_PLUG_ITEM          = 1 &lt;&lt; 3
	...
};

typedef enum reiserfs_plug_kind reiserfs_plug_kind_t;

struct reiserfs_plug_header {
   	uint32_t plug_id;
   	reiserfs_plug_kind_t plug_kind;
   	const char plug_name[REISERFS_PLUG_MAX_NAME];
   	const char plug_desc[REISERFS_PLUG_MAX_DESC];
   	void *plug_data;
};

typedef struct reiserfs_plug_header reiserfs_plug_header_t;

struct reiserfs_plug {
	void *plug_handle;
	uint32_t plug_nlink;

	reiserfs_plug_header_t header;

	union {
		 reiserfs_journal_plug_t journal;
		 reiserfs_alloc_plug_t alloc;
		 reiserfs_layout_plug_t layout;
		 reiserfs_security_plug_t security;
		 reiserfs_dir_plug_t dir;
		 reiserfs_file_plug_t file;
		 reiserfs_node_plug_t node;
		 reiserfs_item_plug_t item;
	} __attribute__ (__packed__) u;
};

typedef struct reiserfs_plug reiserfs_plug_t;
</pre><br>

<b>void *plug_handle</b>

<p>Handle of loaded shared library. It is used for resolving symbols from loaded plugin. Also
it is used for unloading plugin by plugins factory, when plug_nlink reaches zero.</p>

<b>uint32_t plug_nlink</b>

<p>Number of references to underlying plugin. This value is initialized by zero
during first time loading. It is incremented by reiserfs_plug_load function
and decremented by reiserfs_plug_unload function. If "plug_nlink" reaches zero,
then plugin will be unloaded.</p>

<b>uint32_t plug_id</b>
<b>reiserfs_plug_kind_t plug_kind</b>

<p>Plugin identifier and kind/type. It is used for looking plugin up in the plugin cache.
Also it is used for looking in the plugins map in order to find required plugin library. 
For example: plug_id = 0x01, plug_kind = 0x01, file = libreiserfs_journal40.so</p>

<b>const char plug_name[REISERFS_PLUG_MAX_NAME]</b>

<p>Plugin name. For example, "journal40". Will be used to look for plugin up by its 
"plug_name".</p>

<b>const char plug_desc[REISERFS_PLUG_MAX_DESC]</b>

<p>Plugin description. Will contain long plugin description with plugin version and vendor.
For example, "journal40 v.0.2 by NAMESYS. Standard journal plugin for Reiser4".</p>

<b>union {...} u;</b>

<p>Plugin instance.</p>

<pre>
reiserfs_plug_t *reiserfs_plug_load_by_name(const char *name) {
	char *error;
	void *plug_handle;
	void *plug_entry;
	reiserfs_plug_t *plug;
	reiserfs_plug_t *(*gpi) (void);

	ASSERT(name != NULL, return NULL);

	if (!(plug_handle = dlopen(name, RTLD_NOW))) {
		 libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			  "Couldn't load plugin %s.", name);
		 goto error;
	}

	plug_entry = dlsym(plug_handle, "reiserfs_plugin_info");
	if ((error = dlerror()) != NULL) {
		 libreiserfs_exception_throw(EXCEPTION_ERROR, PED_EXCEPTION_IGNORE,
			  _("Couldn't resolve symbol %s. Error: %s."), reiserfs_plugin_info, error);
		 goto error_free_plug_handle;
	}
	gpi = (reiserfs_plug_t *(*)(void))plug_entry;

	plug = gpi();

	plug-&gt;plug_handle = plug_handle;
	plug-&gt;plug_nlink = 0;

	reiserfs_plugin_register(plug);

	return plug;

error_free_plug_handle:
	dlclose(plug_handle);
error:
	return NULL;

}

reiserfs_plug_t *reiserfs_plug_load(reiserfs_plug_kind_t plug_kind, uint32_t plug_id) {
	char *plug_name;
	reiserfs_plug_t *plug;

	/* First of all we are trying to find loaded plugin in plugins cache by it id */
	if ((plug = reiserfs_plug_find(plug_id))) {
		 plug-&gt;plug_nlink++;
		 return plug;
	}

	if (!(plug_name = reiserfs_plug_path_by_id(plug_kind, plug_id))) {
		 libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			  "Couldn't find registered plugin by it identifier %d.", plug_id);
		 goto error;
	}

	if (!(plug = reiserfs_plug_load_by_name(plug_name)))
		goto error;
	
	return plug;
		 
error:
	return NULL;
}
</pre>

<p>As you can see loaded plugins are registered in the plugin cache.</p>

<p>There will be a set of functions (reiserfs_plugin_*) to work with plugins and 
plugin cache.</p>

<b>int reiserfs_plug_register(reiserfs_plug_t *plug)</b>

<p>Registers loaded plugin in the plugins cache. Returns true on success, 
false on failure.</p>

<b>int reiserfs_plug_unregister(reiserfs_plug_t *plug)</b>

<p>Unregisters given plugin.</p>

<b>reiserfs_plug_t *reiserfs_plug_load(uint16_t plug_kind, uint16_t plug_id)</b>

<p>Loads plugin by identifier. If plugin is  already  loaded,
retrieves  it  from the cache. If not, loads it and stores
loaded plugin in the cache.</p>

<b>int reiserfs_plug_unload(reiserfs_plug_t *plug)</b>

<p>Unloads plugin, unregisters it from cache if "plugin_nlink" field reaches zero.</p>
</td></tr></table>

<h3>Compact building.</h3>

<table width=90%><tr><td align=justify>
<p>As libreiserfs will be used by "alone" applications (some boot-loaders), 
we need a mechanism for building libreiserfs in "compact" manner.</p>

<p>In compact building mode libreiserfs will contain: filesystem opening code, 
file and directory access code. All modifying code (resizing, copying, tree 
modifying, etc), block allocator code, oid allocator code will be skipped. 
The acceptable size for libreiserfs built in compact manner and without libc code 
should be about 10k. This is average filesystem-code size in a bootloader. If our 
reiserfs code will take more than 10k then it will be not used by anyone.</p>

<p>Compact building will be turned on by "--compact" option in configure time.<br><br>
<i>./configure --compact && make && make install</i>
</p>
</td></tr></table>

<h3>Builtin plugins.</h3>

<table width=90%><tr><td align=justify>
<p>In order to be used by bootloaders or other "alone" applications, libreiserfs 
needs a mechanism builtin plugins. This ability also will be useful for creating 
the repair reiserfs tools, which should be linked statically to avoid any dependencies
on libc or something else.</p>
</td></tr></table>

<h3>Builtin plugins implementation.</h3>

<table width=90%><tr><td align=justify>
<p>Sorry, not implemented yet!</p>
</td></tr></table>

<hr>

<p><i>Copyright 1996-2002 Hans Reiser</i></p>
</td></tr></table>
</body>
</html>

