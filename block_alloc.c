/*
 * Copyright 2002 by Hans Reiser, licensing governed by reiser4/README
 */

#include "reiser4.h"

/*
 *  Block number allocation and free space counting in reiser4 are done in two
 * stages: first, we assign special block numbers to just created nodes and
 * subtracts a number of that nodes from free blocks counter . Those special
 * numbers have nothing common with real block numbers on a disk device and
 * they are called "fake" in reiser4. Actually only formatted nodes require
 * those numbers because we need something to be inserted into internal nodes
 * and, thus, to support tree operations: lookup and variants of tree
 * modifications. Fake block numbers should be replaced by real "on-disk"
 * block numbers before time we write data to disk. It is a second stage of
 * block numbers allocation.
 *
 * Current implementation of reiser4 uses 64-bit integers for block
 * numbers. We use highest bit in 64-bit block number to distinguish fake and
 * real block numbers. So, only 63 bits may be used to addressing of real
 * device blocks. That "fake" block numbers space is divided into subspaces of
 * fake block numbers for data blocks and for shadow (working) bitmap
 * blocks. Fake block numbers for data blocks are generated by a cyclic
 * counter, which gets incremented after each real block allocation. We assume
 * that it is impossible to overload this counter during one transaction life.
 */


/* Initialize a blocknr hint. */
void blocknr_hint_init (reiser4_blocknr_hint *hint)
{
	hint->blk = 0;
	hint->max_dist = 0;
}

/* Release any resources of a blocknr hint. */
void blocknr_hint_done (reiser4_blocknr_hint *hint UNUSED_ARG)
{
	/* FIXME: relase bitmap lock. */
}

/** is it a real block number from real block device or fake block number for
 * not-yet-mapped object? */
int blocknr_is_fake(const reiser4_block_nr * da)
{
	return (*da & REISER4_FAKE_BLOCKNR_BIT_MASK) ? 1 : 0;
}

/** a generator for tree nodes fake block numbers */
void get_next_fake_blocknr (reiser4_block_nr *bnr)
{
	static spinlock_t       fake_lock = SPIN_LOCK_UNLOCKED;
	static reiser4_block_nr fake_gen  = 0;

	spin_lock (& fake_lock);
	*bnr = fake_gen++;
	spin_unlock (& fake_lock);
	
	*bnr &= ~REISER4_BLOCKNR_STATUS_BIT_MASK;
	*bnr |= REISER4_UNALLOCATED_BIT_MASK;

#if REISER4_DEBUG
	{
		znode * node;

		node = zlook(current_tree, bnr);
		assert ("zam-394", node == NULL);
	}
#endif
}


/* wrapper to call space allocation plugin */
int reiser4_alloc_blocks (reiser4_blocknr_hint *preceder, reiser4_block_nr *blk,
			  reiser4_block_nr *len)
{
	space_allocator_plugin * splug;
	int needed;

	assert ("vs-514", (get_current_super_private () &&
			   get_current_super_private ()->space_plug &&
			   get_current_super_private ()->space_plug->alloc_blocks));

	splug = get_current_super_private ()->space_plug;	
	needed = *len;
	return splug->alloc_blocks (get_space_allocator (reiser4_get_current_sb ()),
				    preceder, needed, blk, len);
}

/* wrapper to call dealloc_blocks method of space allocation plugin */
int reiser4_dealloc_blocks (const reiser4_block_nr * start, const reiser4_block_nr * len)
{
	txn_atom          * atom; 
	int                 ret;
	
	assert ("zam-431", *len != 0);
	assert ("zam-432", *start != 0);

	/* a generic part of dealloc_blocks is to add deleted blocks to
	 * current atom DELETED set */
	do {
		txn_handle        * tx;
		blocknr_set_entry * bsep = NULL;

		tx = get_current_context() -> trans;
		assert ("zam-429", tx != NULL);

		atom = atom_get_locked_by_txnh (tx);
		assert ("zam-430", atom != NULL);

		if (*len == 1) ret = blocknr_set_add_block (atom, & atom->delete_set, &bsep, start);
		else           ret = blocknr_set_add_extent (atom, & atom->delete_set, &bsep, start, len);

	} while (ret != -EAGAIN);

	if (ret != 0) return ret;

	assert ("zam-433", atom != NULL);
	spin_unlock_atom (atom);

	{ /* and a plugin-specific part */
		space_allocator_plugin * splug;

		assert ("zam-425", (get_current_super_private () &&
				    get_current_super_private ()->space_plug ));

		splug = get_current_super_private()->space_plug;

		if (splug -> dealloc_blocks != NULL)
			splug->dealloc_blocks (get_space_allocator (reiser4_get_current_sb ()), *start, *len);
	}

	return 0;
}

/** obtain block number for formatted node */
int alloc_blocknr (znode *neighbor, reiser4_block_nr *blocknr)
{
	if (0) {
		space_allocator_plugin * splug;
		reiser4_blocknr_hint preceder;
		reiser4_block_nr one;

		if (neighbor)
			preceder.blk = ZJNODE (neighbor)->blocknr;
		else
			preceder.blk = 0;

		splug = get_current_super_private ()->space_plug;	
		return splug->alloc_blocks (get_space_allocator (reiser4_get_current_sb ()),
					    &preceder, 1, blocknr, &one);
	} else {
		get_next_fake_blocknr (blocknr);
		return 0;
	}
}

/* 
 * Local variables:
 * c-indentation-style: "K&R"
 * mode-name: "LC"
 * c-basic-offset: 8
 * tab-width: 8
 * fill-column: 78
 * scroll-step: 1
 * End:
 */
